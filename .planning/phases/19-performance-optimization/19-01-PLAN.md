# Plan: 19-01 Performance Baseline & Quick Wins

## Objective

Establish performance baseline with metrics tracking and implement quick wins: command definition caching and batch global memory writes.

## Execution Context

**Phase:** 19 - performance-optimization
**Plan:** 1 of 3
**Depends on:** v3.3 complete

**Key files:**
- `lib/context/context-cache.js` - LRU cache foundation (427 lines)
- `lib/memory/global-memory.js` - Persistence layer (466 lines)
- `lib/validators/command-validator.js` - Command loading

## Context

### Current State
- All file I/O is synchronous (blocking)
- Global memory writes 4 separate files per pattern record
- Command definitions loaded fresh each invocation
- No performance metrics or baselines tracked
- 14 file I/O operations across codebase

### Performance Bottlenecks Identified
1. **Global memory writes** - 4 file writes per pattern (CRITICAL)
2. **No command caching** - Commands re-parsed each time
3. **No metrics dashboard** - Can't measure improvements
4. **Synchronous file I/O** - Blocks event loop

### Target Outcomes
- Performance metrics module for tracking
- Batched/debounced global memory writes (100ms window)
- Cached command definitions (load once per session)
- Baseline metrics captured before further optimization

## Tasks

<task id="1" title="Create performance metrics module">
**Action:** Create `lib/metrics/performance-tracker.js`

**Implementation:**
```javascript
// lib/metrics/performance-tracker.js
class PerformanceTracker {
  constructor() {
    this.metrics = {
      cache: {
        fileContent: { hits: 0, misses: 0, avgHitTimeMs: 0 },
        metadata: { hits: 0, misses: 0, avgHitTimeMs: 0 },
        predictions: { hits: 0, misses: 0, avgHitTimeMs: 0 }
      },
      fileIO: {
        reads: 0,
        writes: 0,
        scans: 0,
        totalBytes: 0,
        timings: []
      },
      commands: {
        cached: 0,
        loaded: 0,
        definitions: new Map()
      },
      memory: {
        batchedWrites: 0,
        immediateWrites: 0,
        patternRecords: 0
      }
    };
    this.sessionStart = Date.now();
  }

  trackFileRead(path, bytes, durationMs) { ... }
  trackFileWrite(path, bytes, durationMs) { ... }
  trackCacheHit(cacheType, durationMs) { ... }
  trackCacheMiss(cacheType) { ... }
  trackCommandLoad(commandName, cached) { ... }
  trackMemoryWrite(batched) { ... }

  getReport() { ... }
  getHitRates() { ... }
  getIOStats() { ... }
  reset() { ... }
}

module.exports = { PerformanceTracker, tracker: new PerformanceTracker() };
```

**Files:**
- Create: `lib/metrics/performance-tracker.js`
- Create: `lib/metrics/index.js`

**Verification:**
- [ ] Module exports PerformanceTracker class and singleton
- [ ] All tracking methods work without errors
- [ ] getReport() returns structured metrics object
</task>

<task id="2" title="Implement batched global memory writes">
**Action:** Add debounced write batching to `lib/memory/global-memory.js`

**Implementation:**
- Add `_pendingWrite` flag and `_writeTimeout` to class
- Modify `save()` to use debounced write (100ms window)
- Add `flush()` method for immediate write when needed
- Batch all 4 file writes into single save operation

**Key changes:**
```javascript
// In GlobalMemory class
constructor() {
  // ... existing
  this._pendingWrite = false;
  this._writeTimeout = null;
  this._batchWindowMs = 100;
}

save() {
  if (this._writeTimeout) return; // Already scheduled

  this._pendingWrite = true;
  this._writeTimeout = setTimeout(() => {
    this._doWrite();
    this._writeTimeout = null;
    this._pendingWrite = false;
    tracker.trackMemoryWrite(true); // batched
  }, this._batchWindowMs);
}

flush() {
  if (this._writeTimeout) {
    clearTimeout(this._writeTimeout);
    this._writeTimeout = null;
  }
  if (this._pendingWrite) {
    this._doWrite();
    this._pendingWrite = false;
    tracker.trackMemoryWrite(false); // immediate
  }
}

_doWrite() {
  // Existing save logic moved here
}
```

**Files:**
- Modify: `lib/memory/global-memory.js`

**Verification:**
- [ ] Multiple rapid pattern records result in single file write
- [ ] flush() forces immediate write
- [ ] Existing tests still pass
- [ ] 70%+ reduction in write operations during rapid activity
</task>

<task id="3" title="Implement command definition caching">
**Action:** Add command definition cache to avoid re-parsing

**Implementation:**
Create `lib/cache/command-cache.js`:
```javascript
class CommandCache {
  constructor() {
    this.definitions = new Map();
    this.loadTime = null;
  }

  get(commandName) {
    return this.definitions.get(commandName);
  }

  set(commandName, definition) {
    this.definitions.set(commandName, definition);
    tracker.trackCommandLoad(commandName, false);
  }

  has(commandName) {
    return this.definitions.has(commandName);
  }

  loadAll(commandsDir) {
    // Load all command definitions at once
    const start = Date.now();
    // ... scan and load all .md files
    this.loadTime = Date.now() - start;
    return this.definitions.size;
  }

  getStats() {
    return {
      size: this.definitions.size,
      loadTime: this.loadTime
    };
  }
}

module.exports = { CommandCache, commandCache: new CommandCache() };
```

**Files:**
- Create: `lib/cache/command-cache.js`
- Create: `lib/cache/index.js`
- Modify: `lib/validators/command-validator.js` to use cache

**Verification:**
- [ ] Commands loaded once per session
- [ ] Subsequent accesses use cached definitions
- [ ] Cache stats available
</task>

<task id="4" title="Add performance tests and baseline">
**Action:** Create performance test suite and capture baseline

**Implementation:**
Create `tests/performance/baseline.test.js`:
```javascript
describe('Performance Baseline', () => {
  describe('Global Memory Batching', () => {
    test('10 rapid pattern records trigger <= 2 file writes', async () => {
      // Record 10 patterns rapidly
      // Wait for batch window
      // Assert file write count
    });
  });

  describe('Command Cache', () => {
    test('loading 40 commands takes < 100ms', () => {
      const start = Date.now();
      commandCache.loadAll(commandsDir);
      expect(Date.now() - start).toBeLessThan(100);
    });

    test('cached command access is < 1ms', () => {
      // Measure cached access time
    });
  });

  describe('Cache Hit Rates', () => {
    test('repeated file access has > 80% hit rate', () => {
      // Access same files multiple times
      // Check hit rate
    });
  });
});
```

**Files:**
- Create: `tests/performance/baseline.test.js`
- Create: `tests/performance/helpers.js`

**Verification:**
- [ ] Performance tests pass
- [ ] Baseline metrics documented
- [ ] Tests run in < 5 seconds
</task>

<task id="5" title="Integrate metrics into existing modules">
**Action:** Add tracker calls to context-cache.js and key I/O points

**Implementation:**
- Import tracker in context-cache.js
- Add trackCacheHit/trackCacheMiss calls in get/set methods
- Add trackFileRead/trackFileWrite in file operations
- Export getPerformanceReport from lib/index.js

**Files:**
- Modify: `lib/context/context-cache.js`
- Modify: `lib/index.js` (export metrics)

**Verification:**
- [ ] Cache hit/miss tracking works
- [ ] Performance report accessible via lib API
- [ ] No performance regression from tracking overhead
</task>

## Verification

```bash
# Run all tests including new performance tests
cd "C:\Users\Prithvi Putta\PMP-GYWD"
npm test

# Run only performance tests
npm test -- tests/performance/

# Verify no regressions
npm test -- --coverage
```

## Success Criteria

- [ ] New `lib/metrics/` module with PerformanceTracker
- [ ] New `lib/cache/` module with CommandCache
- [ ] Global memory writes batched (100ms window)
- [ ] Command definitions cached per session
- [ ] Performance baseline tests pass
- [ ] All 557+ existing tests still pass
- [ ] Metrics tracking integrated into cache system

## Confidence Summary

**Overall: 88%** (High)

| Task | Confidence | Notes |
|------|------------|-------|
| T1: Performance metrics module | 95% | Standard pattern, well-defined |
| T2: Batched memory writes | 85% | Debounce pattern, need flush handling |
| T3: Command caching | 90% | Simple Map cache, clear scope |
| T4: Performance tests | 85% | May need timing adjustments |
| T5: Metrics integration | 82% | Multiple touchpoints, careful integration |

**Factors affecting confidence:**
- Existing codebase is well-structured and modular
- No external dependencies to manage
- Debounce timing may need tuning in CI environment
- Integration touches multiple files but changes are localized

## Output

After execution, provide:
1. New modules created (lib/metrics/, lib/cache/)
2. Files modified with batching/caching
3. Performance baseline numbers
4. Test results summary
5. Any deferred items for next plan

## Checkpoint

<checkpoint type="human-verify" after="task-4">
Before integrating metrics into existing modules, verify:
- Performance tests pass locally
- Baseline numbers are reasonable
- No test flakiness observed
</checkpoint>
